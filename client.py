from cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives.asymmetric import rsaimport josepy as joseimport OpenSSLfrom OpenSSL import cryptofrom acme import clientfrom acme import errorsfrom acme import messagesfrom challenge import EmailReply00import time, signal, re# Constants:# This is the staging point for ACME-V2 within Let's Encrypt.DIRECTORY_URL = 'https://acme.castle.cloud/acme/directory'USER_AGENT = 'python-acme-example'# Account key sizeACC_KEY_BITS = 2048# Certificate private key sizeCERT_PKEY_BITS = 2048# Domain name for the certificate.DOMAIN = 'trocotronic@redyc.com'   def dummy(signal,frame):    print('Press CTRL+D for quit')    def is_email(domain_name):    REGEX = r'^[\w\-\.]+@([\w\-]+\.)+[\w\-]{2,4}$'    return re.fullmatch(REGEX, domain_name)    def new_csr_comp(domain_name, pkey_pem=None):    if pkey_pem is None:        private_key = OpenSSL.crypto.PKey()        private_key.generate_key(OpenSSL.crypto.TYPE_RSA, CERT_PKEY_BITS)        pkey_pem = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, private_key)    else:        private_key = crypto.load_privatekey(crypto.FILETYPE_PEM, pkey_pem)    csr = crypto.X509Req()    extensions = [        crypto.X509Extension(            b'subjectAltName',            critical=False,            value=', '.join(('email:' if is_email(d) else 'DNS:') + d for d in domain_name).encode('ascii')        ),    ]    csr.add_extensions(extensions)    csr.set_pubkey(private_key)    csr.set_version(2)    csr.get_subject().__setattr__('commonName', domain_name[0])    csr.sign(private_key, 'sha256')    csr_pem = crypto.dump_certificate_request(crypto.FILETYPE_PEM, csr)    return pkey_pem, csr_pem    def select_emailreply00_chall(orderr):    authz_list = orderr.authorizations    for authz in authz_list:        for i in authz.body.challenges:            if isinstance(i.chall, EmailReply00):                return i    raise Exception('EmailReply-00 challenge was not offered by the CA server.')    def perform_emailreply00(client_acme, challb, orderr):    response, _ = challb.response_and_validation(client_acme.net.key)    client_acme.answer_challenge(challb, response)        # Wait for the user input    print('A challenge request for S/MIME certificate has been sent.\n'        'In few minutes, ACME server will send a challenge e-mail to requested recipient.\n'        'Please, copy the ENTIRE subject and paste it below. The subject starts with the label ACME:\n\n')    subject = input('Subject: ')    while (subject[0:6] != 'ACME: '):        print('Wrong format. Please, introduce the subject AS IS, with the ACME: label.')        subject = input('Subject: ')            token64 = subject.split(' ')[-1]    token1 = jose.b64.b64decode(token64)        full_token = bytearray(challb.chall.token)    full_token[:len(challb.chall.token)//2] = token1    # We reconstruct the ChallengeBody    challt = messages.ChallengeBody.from_json({ 'type': 'email-reply-00', 'token': jose.b64.b64encode(bytes(full_token)).decode('ascii'), 'url': challb.uri, 'status': challb.status.to_json() })    _, validation = challt.response_and_validation(client_acme.net.key)        print('A challenge response has been generated.\n'        'Please, copy the following text, reply the e-mail you have received from ACME server and paste this text in the TOP of the message\'s body:\n\n'        '-----BEGIN ACME RESPONSE-----\n'        '{}\n'        '-----END ACME RESPONSE-----\n'.format(validation))            #let user some time to reply        time.sleep(10)        finalized_orderr = client_acme.poll_and_finalize(orderr)        return finalized_orderr.fullchain_pemdef main_emailreply00():    acc_key = jose.JWKRSA(        key=rsa.generate_private_key(public_exponent=65537,                                     key_size=ACC_KEY_BITS,                                     backend=default_backend()))    net = client.ClientNetwork(acc_key, user_agent=USER_AGENT)    directory = messages.Directory.from_json(net.get(DIRECTORY_URL).json())    client_acme = client.ClientV2(directory, net=net)    email = ('fake@example.com')    regr = client_acme.new_account(messages.NewRegistration.from_data(email=email, terms_of_service_agreed=True))                client_acme.net.account = regr    try:        regr = client_acme.query_registration(regr)    except errors.Error as err:        if err.typ == messages.OLD_ERROR_PREFIX + 'unauthorized' or err.typ == messages.ERROR_PREFIX + 'unauthorized':            # Status is deactivated.            pass        raise            pkey_pem, csr_pem = new_csr_comp([DOMAIN])        orderr = client_acme.new_order(csr_pem)        challb = select_emailreply00_chall(orderr)        fullchain_pem = perform_emailreply00(client_acme, challb, orderr)        if (fullchain_pem):        cert = crypto.load_certificate(crypto.FILETYPE_PEM, fullchain_pem)        privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pkey_pem)        pfx = crypto.PKCS12()        pfx.set_privatekey(privkey)        pfx.set_certificate(cert)        print('Exporting certificate and private key to PKCS12 container')        pf = input('Enter passphrase: ')        vpf = input('Re-enter passphrase: ')        while (pf != vpf):            print('Passphrases do not match.')            vpf = input('Re-enter passphrase: ')        pfxdata = pfx.export(pf.encode('ascii'))        with open('test.pfx', 'wb') as pfxfile:            pfxfile.write(pfxdata)    # Change contact information    email = 'newfake@example.com'    regr = client_acme.update_registration(        regr.update(            body=regr.body.update(                contact=('mailto:' + email,)            )        )    )    # Deactivate account/registration    regr = client_acme.deactivate_registration(regr)if __name__ == "__main__":    signal.signal(signal.SIGINT, dummy)    main_emailreply00()    